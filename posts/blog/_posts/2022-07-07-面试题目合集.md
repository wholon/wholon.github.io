# 面试题目合集

## 如何翻墙

使用VPN（虚拟专用网络）翻墙啊，推荐用LoCoVPN，下载客户端，使用客户端连接。 

## 基本磁盘和动态磁盘的区别

基本磁盘和动态磁盘是Windows中的两种硬盘配置类型，大多数个人计算机都配置为基本磁盘，该类型最易于管理。

基本磁盘：

受26个字母限制，盘符只能从C到Z（A\B被软驱占用）。基本磁盘上在一个硬盘上只能最多建立四个主分区，分区必须相邻。基本磁盘一旦分区不能更改大小，除非借助第三方工具。

动态磁盘：

动态磁盘不再采用基本磁盘的分区方式，而是叫做卷集。分为简单卷、跨区卷、带区卷、镜像卷和RAID-5卷。动态磁盘在一个硬盘上可创建的卷集数没有限制。动态磁盘可以把几个不同的硬盘建成一个卷，并且这些分区可以非相邻。动态磁盘可以不重启机器的情况下调整分区大小，并且不会丢失数据。动态磁盘还有容错功能。

基本磁盘可以直接转换为动态磁盘，但该过程不可逆。想要转回基本磁盘，只有把数据全部拷出，然后删除硬盘所有分区后才能转回去。

可在基本磁盘上创建的分区个数取决于分区形式是MBR还是GPT。

基本磁盘、动态磁盘针对的对象时整个磁盘。GPT和MBR是针对磁盘的某个分区的分区方式。GPT\MBR和基本磁盘\动态磁盘根本就是两个不同的概念，互相没有联系！！！！

## GPT磁盘与MBR磁盘的区别

在使用新磁盘之前，必须对其进行分区。MBR和GPT是在磁盘上存储分区信息的两种不同的方式。

GPT是一种新的标准，并在逐渐取代MBR，但MBR仍拥有最好的兼容性。MBR已经成为磁盘分区和启动的工业标准。

MBR的局限性：

MBR的意思是“主引导记录”，MBR支持最大2TB硬盘，无法处理大于2TB容量的磁盘。MBR还只支持最多4个主分区（如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区）。

GPT的优势：

GPT意为“GUID分区表”（GUID意为全局唯一标识符）。与UEFI相辅相成（UEFI取代老旧的BIOS）。

可以保证你的驱动器上每个分区都有一个全球唯一的标识符。

磁盘容量可以超级大，大到操作系统不支持，支持无限个分区数量，限制在于操作系统——Windows支持最多128个GPT分区，而且不需要创建扩展分区。

在MBR磁盘上，分区和启动信息是保存在一起的，如果这部分数据被损坏，就无法启动计算机了。但GPT在磁盘的上保存多个这部分信息的副本，如果数据被破坏，可以进行修复。

## PHP、CSS、HTML、JS之间的关系

HTML是一种标签语言，静态页面，由客户端的浏览器负责解析。

CSS是一种样式控制，也就是如何定义一个网页的布局、颜色等外观，也由浏览器负责解析。

JS是一种客户端动态脚本，使用户可以控制页面上的动态内容显示，也就是用户交互。

PHP是一种服务端动态语言，最终会动态生成html供客户端浏览器解析。

总结：

html,css,js都是客户端语言，都是由浏览器解析执行。php是服务端语言（和java,C#一样是编程语言的一种，做Web开发都可以用），运行在远程服务器上，其最终需要生成html才可以被浏览器识别。

形象比喻：

简单的说就像是装修房子一样，装修队就是浏览器

你把你的设计（html==装修图纸）告诉浏览器，它就会按照你给的装修图纸进行房屋的摆设和装饰。

所以html包含了两大块，一是屋子里是怎么样摆设，二摆设是需要怎样的装饰点缀，那么他们就分别是html基本元素和css层叠样式表。也就是说css对html进行了详细的说明，是对细节的描写。

js则可以根据客户的需求动态的改html里的摆设和装饰。

html包含了css和js形成了完成的装修方案，是属于前端的描述语言和脚本

而php是在服务器端运行的脚本，通过与数据库和其他组件进行交互的操作，可以动态的生成多套设计方案即html(装修图纸)

## WAMP,LAMP,LNMP的区别

以上都是一个集成的Web应用程序平台。

WAMP是Windows下的Apache+Mysql+PHP

LAMP是Linux下的Apache+Mysql+PHP

LNMP是Linux下的Nginx+Mysql+PHP

Apache是世界上使用排名第一的Web服务器软件，Nginx是一个高性能的HTTP和反向代理服务器。

MySQL是关系型数据库管理系统。 

目前有不少AMP的集成软件，可以让我们一次性安装并设置好，是绝佳的一站式环境配置，例如WampServer。 

## HTTPS和HTTP的区别

HTTP即超文本传输协议是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。

网站的访问都要先看协议，协议不一样，则访问不了。

HTTPS是以安全为目标的HTTP通道，简单讲就是HTTP的安全版。即HTTP下加入SSL层。HTTPS存在不同于HTTP的默认端口以及一个加密身份验证层（在HTTP于TCP之间）。

HTTPS和HTTP的区别主要为以下四点：

1. https协议需要到ca申请证书，一般免费证书很少，需要交费。

2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443.

4. http的连接很简单，是无状态的，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## POST和GET的区别

来自 <http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html> 

Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。

1. 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

\* 注意：这里安全的含义仅仅是指是非修改信息。

(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下**幂等**这个概念：

**幂等**（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。

幂等有一下几种定义：

对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有A的绝对值=A的绝对值的绝对值。

对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。

看完上述解释后，应该可以理解GET幂等的含义了。

但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。

2. 根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。

 

上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：

1. 很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。

2. 对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。

3. 另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。

以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。

## 简单解释一下MVC：

MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。

说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：

1. GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

POST把提交的数据则放置在是HTTP包的包体中。

2. "GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB"？？！

以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：

(1).首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5]

(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。

对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。

由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：

1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。

2).IIS 6.0默认上传文件的最大大小是4MB。

3).IIS 6.0默认最大请求头是16KB。

IIS 6.0之前没有这些限制。[见参考资料5]

所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。

3. 在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\"XXXX\")来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&password=hyddd，用request.getQueryString()得到的是：name=hyddd&password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。

4. POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。

总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发！

## MVC模式

来自 <http://baike.baidu.com/link?url=hYCYH4VltmoiE8SYen_iArQJ7ZuvOYCWb4PBxX3sd7fN61NI0egZ6t18DT9qCtGU0yYgYxWPUnWSOCUFO9eXC168_Wf6TeVogQodyW5TukPCwha5CgMpSwXPaGvhuLGXGsKe5oA0-yjWLhGIg7AWLnS32DHQsHJhyOxi52ljmh3> 

MVC全名是model view controller，M代表业务模型，V代表用户界面，C代表控制器。是一种软件架构模式。

用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。使用MVC的目的是使M和V的代码分离，从而使一种程序有不同的表现形式。C的目的是确保M和V同步，一旦M改变，V应该同步刷新。

**Model（模型）**是应用程序中用于处理应用程序数据逻辑的部分。

通常模型对象负责在数据库中存取数据。

**View（视图）**是应用程序中处理数据显示的部分。

通常视图是依据模型数据创建的。

**Controller（控制器）**是应用程序中处理用户交互的部分。

通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/202206211757400XxNIp.png) 

## Web开发中的cookie和session

### Cookie：

 Cookies是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。Cookies是当浏览某网站时，由WEB服务器置于硬盘上的一个非常小的文本文件，它可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当再次来到该网站时，网站通过读取cookies,得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等。

从本质上讲，它可以看作是你的身份证。但cookie不能作为代码执行，也不会传送病毒，且为你所专有，并只能由提供它的服务器来读取。一个网站只能取得它放在你的电脑中的信息，它无法从其它的cookies文件中取得信息，也无法得到你的电脑上的其它任何东西。Cookies中的内容大多数经过了加密处理，因此一般用户看来只是一些毫无意义的字母数字组合，只有服务器的CGI处理程序才知道它们真正的含义。

服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本，如JAVASCRIPT或者VBSCRIPT也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。

Cookie的内容主要包括：名字、值、过期时间、路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不会存储在硬盘上而是保存在内存里。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

### Session: 

session机制是一种服务器端的机制，当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。

当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标志（称为session id）,如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）；如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id 将被在本次响应中返回给客户端保存。

由于采用服务器端保持状态的方案在客户端也需要保存一个标志，所以session机制可能需要借助于cookie机制来达到保存标志的目的，但实际上它还有其他选择。

Cookie和Session的区别：

1. Cookie保存在客户端，Session保存在服务端。

2. Cookie不是很安全，因为存放在本地。

3. 单个Cookie的数据不能超过4K，很多浏览器都限制一个站点最多保存50个Cookie。 

## 常见的Web安全漏洞

SQL名词解释：

SQL（Structured Query Language）即结构化查询语言，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。

### SQL注入

概述：

就是通过把SQL命令插入到WEB表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令。

可能原因：

未对用户输入执行正确的危险字符清理

技术描述：

它是利用现有的程序，将恶意的SQL命令注入到后台数据库，它可以通过WEB表单中输入恶意SQL语句得到一个存在安全漏洞的网站上的数据库。

Web 应用程序通常在后端使用数据库，以与企业数据仓库交互。查询数据库事实上的标准语言是 SQL（各大数据库供应商都有自己的不同版本）。Web 应用程序通常会获取用户输入（取自 HTTP 请求），将它并入 SQL 查询中，然后发送到后端数据库。接着应用程序便处理查询结果，有时会向用户显示结果。 

如果应用程序对用户（攻击者）的输入处理不够小心，攻击者便可以利用这种操作方式。在此情况下，攻击者可以注入恶意的数据，当该数据并入 SQL 查询中时，就将查询的原始语法更改得面目全非。例如，如果应用程序使用用户的输入（如用户名和密码）来查询用户帐户的数据库表，以认证用户，而攻击者能够将恶意数据注入查询的用户名部分（和/或密码部分），查询便可能更改成完全不同的数据复制查询，可能是修改数据库的查询，或在数据库服务器上运行 Shell 命令的查询。

例子：

程序从Http 请求中读取一个sql 查询

String sql ="SELECT * FROM accountWHERE name = 'Bob'AND password = '123'"

stmt.execute(sql)

在执行execute(sql)之前并未对输入的字符串进行检查，因此存在SQL注入弱点，如果在password="123"后加上or’1=1‘，那么这样的SQL注入会使得输入任意密码进入程序。

防范：

1.永远不要信任用户的输入，要对用户的输入输出进行校验，可以通过正则表达式，或限制长度，或者使用过滤函数，对单引号和双"-"进行转换等。

2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。

3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

\4. 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。

### 路径遍历

概述：

可能会查看WEB服务器（在WEB服务器用户的许可权限制下）上的任何文件（例如数据库、用户信息或配置文件）的内容。

可能原因：

未对用户输入执行正确的危险字符清理

未检查用户输入中是否包含“..”（两个点）字符串

技术描述：

CGI 脚本通常包含指定作为模板显示或使用的文件的参数。如果应用程序未验证为脚本提供的文件名，那么攻击者可能会操纵该参数，并请求驻留于服务器上的其他文件。

示例：

[原始的 HTML 表单]  

 <FORM METHOD=POST ACTION="/cgi-bin/vulnerable_script.cgi"> 

 ... 

 <INPUT TYPE=HIDDEN NAME="template" VALUE="/dir1/dir2/template.txt"> 

 ... 

 </FORM> 

 

[受操纵的 HTML 表单] 

 <FORM METHOD=POST 

ACTION="http://target/cgi-bin/vulnerable_script.cgi"> 

 ... 

 <INPUT TYPE=HIDDEN NAME="template" VALUE="../../../../../boot.ini"> 

 ... 

 </FORM> 

如此一来，应用程序在将表单提交回服务器时，会为攻击者提供 boot.ini 文件。

### 跨站点脚本（XSS）

概述：

它指的是恶意攻击者往WEB页面或者客户端脚本的页面里插入恶意html代码，当用户浏览该页时，嵌入其中WEB里面的html代码会被执行，从而达到恶意用户的特殊目的。

可能原因：

WEB应用程序使用客户端创建的WEB页面

技术描述：

Stored XSS（存储式跨站脚本攻击）这是最强大的一种XSS攻击，所谓存储跨站攻击是指用户提交给Web应用程序的数据首先就被永久的保存在服务器的数据库，文件系统或其他地方，后面且未做任何编码就能显示到Web页面。

### 错误认证和会话管理

概述：

“遭破坏的认证和会话管理”，简而言之，就是攻击者窃听了我们访问http时的用户名和密码，或者是我们的会话，从而得到sessionID，进而冒充用户进行http访问的过程。

可能原因：

WEB应用程序将敏感的会话信息存储在永久Cookie中（磁盘上）

明文传输

技术描述：

由于HTTP本身是无状态的，也就是说HTTP的每次访问请求都是带有个人凭证的，而SessionID就是为了跟踪状态的，而sessionID本身是很容易在网络上被监听的到，所以攻击者往往通过监听sessionID来达到进一步攻击的目的。

### 跨站请求伪造（CSRF）

概述：

尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。

技术描述：

在用户会话下对某个CGI做一些GET/POST的事情——这些事情用户未必知道和愿意做，你可以把它想做HTTP会话劫持。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。

假设你是一台存储了丰富内容的计算机，这些内容分为秘密、公开两类，秘密信息只能让A用户查看，公开信息允许任何人查看。你和用户之间通过线缆通信，这些线缆有可能丢失、搞错信息，更糟糕的是其他人也有可能窃取线缆中的信息，现在，试着制定一套你和用户们都遵守的规章制度，让你可以为A和其他用户提供安全、准确的服务。（需要详细阐述如何处理安全和准确这两个问题）

解答：

公开信息允许任何人查看，直接进行明文传输。

秘密信息因为只能让A用户查看，为了安全性，我（计算机、服务端）首先生成一个随机的对称密钥，然后用该对称密钥对明文信息进行加密。下一步则是如何将对称密钥传给用户A，这时候公钥密码就可以完成该任务，只需要使用接受者的公钥加密随机的对称密钥即可。这个公钥应该是用户A自己在通信开始前知道的，也相当于A的身份背书，A不应该将自己的密钥告诉别人，否则相当于把银行卡密码告诉了别人。通信开始的过程如下：

A→服务端：我是用户A，我的公开密钥是Ea，你选择一个对称密钥K，用Ea加密后传送给我；

服务端→A：确定Ea密钥是正确的，相当于确认用户密码，使用Ea加密对称密钥K；

A→服务端：使用K加密传输信息；

服务端→A：使用K加密传输信息。

但是题目中设定有人可能窃取线缆中的信息，也就是恶意用户可能窃取到A的公开密钥Ea，所以存在安全隐患。所以这就需要能被用户信任的第三方机构来提供用户身份验证，即CA机构。因此在上述通信前双方需要获得CA机构颁发的数字证书，并验证证书的完整性、可信性，再进行通信。

为了保证信息的完整性。以上传输都可以再加上一层CRC校验，CRC校验的优点在于信息字段和校验字段的长度可以任意选定。在通信过程中，如果CRC校验错误，则重新请求，直到校验正确再返回数据。

## TCP/IP

TCP/IP是因特网的通信协议，通信协议是计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。

在 TCP/IP 中包含一系列用于处理数据通信的协议：

- TCP (传输控制协议) - 应用程序之间通信，在双方“握手”后建立连接。
- UDP (用户数据包协议) - 应用程序之间的简单通信，无连接的，可靠性稍低。
- IP (网际协议) - 计算机之间的通信，是无连接的，不占用通信线路，当一个IP包从一台计算机被发送，它会到达一个IP路由器，再由IP路由器将这个包路由至它的目的地。每个包的路径可能不同。
- ICMP (因特网消息控制协议) - 针对错误和状态
- DHCP (动态主机配置协议) - 针对动态寻址

TCP/IP意味着TCP和IP在一起协同工作，TCP负责将数据分割并装入IP包，然后在它们到达的时候重新组合。IP负责将包发送给接受者。

一个字节=8比特，因此IP地址使用了4个字节

## cmd 命令行提示符

cd\ 打开根目录

cd.. 退回上一级目录

md xxx 创建xxx文件夹

rd xxx 删除xxx文件夹

dir 列出当前目录下的文件夹

cd xxx\xx 打开xxx中的xx文件夹

del xxx 删除文件

exit 退出DOS命令行

set 查看或者定义环境变量的值

Set path  先找当前目录，再找path设置好的目录

Set path=%path%  添加了原path

Set classpath=xxx 设置环境变量

Set classpath=xxx;  添加了分号，找了指定目录的环境变量后，还会在当前目录找环境变量。但通常不建议加！

Set classpath=xxx;xxxxx 先找xxx，再找xxxxx

Set classpath=.  点代表当前路径

Set classpath=   什么也不写，就清空环境变量

## Linux命令提示符

http://blog.csdn.net/ljianhui/article/details/11100625/