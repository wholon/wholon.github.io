# JVM-内存区域、字节码执行引擎

## 内存区域

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/20220621172917Rbpb2J.png)

1. 程序计数器：知道线程执行位置，保证线程切换后能恢复到正确的执行位置。

2. 虚拟机栈：存栈帧。栈帧里存局部变量表、操作栈、动态连接、方法返回地址。局部变量表又存了各种基本数据类型和**对象引用（句柄）**。

3. 本地方法栈：为Native方法服务

4. 堆：存放**对象实例**和**数组**，可以处于物理上不连续的内存空间

5. 方法区：存类信息、**常量**、**静态变量**。有运行时常量池，存放类的符号引用

堆主要用来存放对象，栈主要用来执行程序。

## 对象的创建

1. 虚拟机遇到一条new指令时，会先去常量池检测能否找到new对应的类的符号引用，并检测这个类是否加载、初始化。

2. 如果加载检查通过，则分配内存。分配内存有两种方式：⑴指针碰撞，针对连续内存区域；⑵空闲列表，针对不连续内存区域

3. 内存分配完之后，会对内存初始化零值，保证实例字段能在java代码不赋初值也能使用。

4. 接下来对对象信息进行设置，把类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息存放在对象头之中

5. 最后执行用户的Init方法

## 对象的内存布局

1. 分为三部分，对象头、实例数据、对齐填充

2. 对象头：⑴对象自身运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁等。⑵类型指针，虚拟机通过这个来确定这个对象是哪个类的实例。⑶如果对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据。

3. 实例数据：对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。

4. 对齐填充：JVM要求对象的起始地址必须是8字节的整数倍，因此当对象实例数据没有对齐时，这部分来补全。

## 对象的访问定位

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/20220621172938uSJeWr.png)

1. 取决于虚拟机的实现而定，有“句柄”和“直接指针”两种方式

2. “句柄”的好处是，在对象被移动（垃圾回收时很普遍），只用修改句柄中的实例数据指针，而reference本身不用修改。

3. “直接指针”的好处是，速度更快，毕竟节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这部分开销节省下来也很可观。

## JVM字节码执行引擎

字节码文件即类文件被加载后，就能送入执行引擎了：

1. 输入：字节码文件
2. 处理：字节码解析
3. 输出：执行结果。

物理机的执行引擎是由硬件实现的，虚拟机的执行引擎由于自己实现的。

### 运行时栈帧结构

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/202206211729560QMiFu.png)

- 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine     Stack）的栈元素。

- 每个栈帧都包括了一下几部分：局部变量表、操作数栈、动态连接、方法的返回地址     和一些额外的附加信息。
- 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
- 一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。

### 局部变量表：

一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。以变量槽slot为单位，一个slot可以放32位数据类型，对于long\double占用2个slot。

### 操作数栈：

即用来存放操作数的栈结构，当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈和出栈的操作。

java虚拟机的解释执行引擎称为基于栈的执行引擎，其中所指的栈就是操作数栈。

### 动态连接：

运行期将相关的符号引用转换为直接引用

### 方法返回地址：

方法执行完成的结果值

### 方法调用：

解析方法的符号引用和确定方法的版本

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/2022062117301467LAgf.png)

方法的执行

1. 解释执行（通过解释器执行）
2. 编译执行（通过JIT编译器产生本地代码执行）

## 基于栈的代码执行示例

下面我们用简单的案例来解释一下JVM代码执行的过程，代码实例如下：

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/20220621173031uHv6Nb.png)

使用javap指令查看字节码：

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/20220621173046DiUiTU.png)