# TopK排序

## 无重复数组找Top K

例子：有一个长度为1000万的int数组，各元素互不重复。如何以最快的速度找出其中最大的100个元素？

1. 快速排序，时间复杂度NlogN

2. 堆排序，时间复杂度NlogN，优点是节省内存

3. 如果没有对内存和系统资源的要求，可以采用多线程，将1000万大小的数组分割为1000个元素组成的若干小数组，利用JDK自带的高效排序算法void java.util.Arrays.sort(int[] a)来进行排序，多线程处理，主线程汇总结果后取出各个小数组的top 100，归并后再进行一次排序得出结果。速度比1、2、快。

4. 位图数组，前提是无重复数组，时间复杂度O(N)，内存占用为数组最大长度除以32+1 

## 有重复数组找Top K

1. 快速排序或者堆排序，时间复杂度NlogN

2. 当N>>K。可以使用快速排序中的partition函数，时间复杂度为O(NlogK)。
   1. 将数组分为两个组，A和B。 
   2. 若A组的个数大于K，则继续在A分组中找取最大的K个数字     。 
   3. 若A组中的数字小于K     ，其个数为T，则继续在B中找取 K-T个数字 。 

3. 当N个数都是正整数，且取值范围不大的时候。可以使用空间换时间的方法，使用一个数组记录每个元素出现的次数，数组长度为maxN，即N个数中的最大元素的值，然后找出最大的K个数。时间复杂度为O(N)+O(maxN)，近似为O(N)。