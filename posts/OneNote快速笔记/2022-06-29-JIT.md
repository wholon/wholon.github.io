# JIT

JIT=动态编译+优化

JIT之后，Java并不比C++慢

JIT技术是JVM中最重要的核心模块之一。我的课程里本来没有计划这一篇，但因为不断有朋友问起，Java到底是怎么运行的？既然Hotspot是C++写的，那Java是不是可以说运行在C++之上呢？为了澄清这些概念，我才想起来了加了这样一篇文章，算做番外篇吧。 

## **Just In Time**

- Just     in time编译，也叫做运行时编译，不同于 C / C++     语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。
- 还有一种，就是**把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高**。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。
- 这种在运行时按需编译的方式就是Just     In Time。

## **主要技术点**

其实JIT的主要技术点，从大的框架上来说，非常简单，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的Java方法，翻译成机器码，写入到这块内存里。当再需要调用原来的Java方法时，就转向调用这块内存。

## **JIT方法内联**

比如A方法里调用了B方法，方法内联就是把B方法的代码直接写到A方法里，使A\B方法合成一个方法。这就是getter/setter无需优化的原因。

## **JIT逃逸分析**

1. 同步消除

如果实际只有一条线程访问对象，则消除对象方法的Synchronized，例外是StringBuffer，因内联父类失败

2. 标量替换

如果对象只在方法内使用，则不会在栈上分配对象，而是只创建对象的属性。

比如：

A a = new A(); a.b=1; 变成 int b=1;

### 解释器，C1和C2

在Hotspot中，解释器是为每一个字节码生成一小段机器码，在执行Java方法的过程中，每次取一条指令，然后就去执行这一个指令所对应的那一段机器码。256条指令，就组成了一个表，在这个表里，每一条指令都对应一段机器码，当执行到某一条指令时，就从这个表里去查这段机器码，并且通过 jmp 指令去执行这段机器码就行了。

这种方式被称为模板解释器。

模板解释器生成的代码有很多冗余，就像我们上面的第一个例子那样。为了生成更精简的机器码，我们可以引入编译器优化手段，例如全局值编码，死代码消除，标量展开，公共子表达式消除，常量传播等等。这样生成出来的机器码会更加优化。

但是，生成机器码的质量越高，所需要的时间也就越长。JIT线程也是要挤占Java 应用线程的资源的。**所以C1是一个折衷，编译时间既不会太长，生成的机器码的指令也不是最优化的，但肯定比解释器的效率要高很多**。

如果一个Java方法调用得足够频繁，那就更值得花大力气去为它生成更优质的机器码，这时就会触发C2编译，**c2是一个运行得更慢，但却能生成更高效代码的编译器。**

由此，我们看到，其实Java的运行，几乎全部都依赖运行时生成的机器码上。所以，对于文章开头的那个问题“Java是运行在C++上的吗？”，大家应该都有自己的答案了。这个问题无法简单地回答是或者不是，正确答案就是Java的运行依赖模板解释器和JIT编译器。

来自 <https://zhuanlan.zhihu.com/p/28476709> 