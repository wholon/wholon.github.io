# 缓存设计

![未命名图片](https://holon-image.oss-cn-beijing.aliyuncs.com/20220621175613xLFtTd.png)

## 缓存优缺点

缓存的优点就是“快”，一个快字基本能概括了。如上文说的加速读写，分流对数据库的压力，归根结底就是对快字的应用及其本身。

缺点主要是下面三点：

1. 数据不一致性：DB的数据与缓存中的数据不一致；
2. 开发成本：需要同时处理缓存层跟DB层的逻辑，增加了开发成本；
3. 维护成本：例如需要对缓存层进行一个监控，增加了运维的成本。

## 因为有成本，所以要考虑缓存对象

被缓存的数据一般具有以下特点：

1. 经常被访问 ：不经常被访问的数据即使缓存了对系统的性能吞吐也没太大的改善，没什么必要做缓存，直接访问DB、File、其他系统即可。
2. 改动不频繁 ：如果一个数据改动很频繁，缓存的数据很容易就过期或者失效，保证数据一致性成本很高，命中率也很难上去，缓存的效果也不会好。
3. 时效性不强 ：业务上要能容忍缓存失效前数据的不准确性。比如产品价格在页面展示的时候可以取缓存的数据，但在结算的时候一定要取数据库的值。

## 针对数据不一致性，要考虑缓存的更新策略

一般来说缓存也是需要有生命周期的，需要被更新或者删除，这样才能保持缓存的可控性。

解决方案：

对数据实时性、一致性要求高用主动更新，对实时性要求不高用超时删除。

- 主动更新：MySQL     binlog增量订阅消费+消息队列+处理并把数据更新到redis [具体实现](onenote:Java面试复习课程.one#常见面试问题1&section-id={D2470621-F6D2-46BF-88CD-F75AE177458C}&page-id={91689A7E-60E2-4ABA-B6FE-F8B2E32A95E6}&object-id={8A24345E-1C64-4B4E-A6D3-7D3C1D85AE08}&11&base-path=https://d.docs.live.net/685282c139d84575/文档/松 的笔记本) 
- 超时删除：在设置缓存的时候可以设置过期时间，在时间到期之后自动删除。

## 考虑缓存粒度

- 假设一张用户表有20个字段，那是否需要将全部字段都放到缓存中？这就涉及到一个粒度的问题！

- 数据字段放少了，就会出现了不通用的问题；数据字段放多了，空间占用也多，序列化跟反序列化消耗的性能更多了。

解决方案：

在粒度这个问题上还是需要根据通用性，代码维护，性能跟空间占用这几点上进行考虑， 简单来说就是靠经验了。

## 考虑缓存穿透

缓存穿透指的是查询一个不存在的数据，DB跟缓存都不会命中的数据。这样的话每次查询都会到DB层中查询，DB层负载加大还有可能造成死机，这样缓存就失去了保护DB层的意义。出现这种情况有两种：1.攻击，爬虫的大量请求；2.业务自身有问题。

解决方案：

1. 缓存空对象，一般用这个，当DB层也查不到数据的时候，缓存一个null值进缓存，这样下一次的话就直接从缓存中读取，保护了后端。不过这种带来的后果是缓存了更多的键，需要更多的空间。
2. 布隆过滤器拦截，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。这样在查询缓存之前先去过滤器中查询缓存是否有存在该key。不过这个适合于数据量固定且较少，实时性低的应用中，因为要维护这一个过滤器，数据大的时候布隆过滤器误算率高。

**布隆过滤器** 来自 <http://blog.csdn.net/better_jh/article/details/77187897> 

## 考虑雪崩优化

雪崩指的是原先的缓存层承载了大量的请求，有效的保护了DB层，但是假如缓存层炸了，那所有的请求都直接穿透到DB层，会容易造成DB层也炸了。

解决方案：

1. 保证缓存层的高可用性，比如Redis的Sentinel哨兵模式（主从模式下，额外有一个Redis当哨兵，如果master挂了，哨兵从Slaver中重新选一个master出来）和Redis的Cluster集群模式都实现了高可用性。
2. 提前演练，模拟某一层挂了，看看怎么调整配置。